// Silent Loan Circle - Privacy-Preserving ROSCA Implementation
// Professional Hackathon Submission
pragma language_version 0.17.0;

import CompactStandardLibrary;

// ============================================================================
// ENUMS & TYPES
// ============================================================================

enum CircleState {
  JOINING,
  ACTIVE,
  COMPLETED
}

// ============================================================================
// LEDGER STATE
// ============================================================================

export ledger contributionAmount: Uint<64>;
export ledger maxMembers: Uint<32>;
export ledger admin: Bytes<32>;

export ledger circleState: CircleState;
export ledger memberCount: Uint<32>;
export ledger currentCycleIndex: Uint<64>;
export ledger payoutPointer: Uint<32>;

// Simple member tracking
export ledger member0: Bytes<32>;
export ledger member1: Bytes<32>;
export ledger member2: Bytes<32>;
export ledger member3: Bytes<32>;

// Contribution tracking for current cycle
export ledger totalContributed: Uint<64>;
export ledger contributionsReceived: Uint<32>;

export ledger round: Counter;

// ============================================================================
// CONSTRUCTOR
// ============================================================================

constructor() {
  contributionAmount = disclose(1000 as Uint<64>);
  maxMembers = disclose(4 as Uint<32>);
  admin = disclose(publicKey(round, adminSecretKey()));
  
  circleState = CircleState.JOINING;
  memberCount = disclose(0 as Uint<32>);
  currentCycleIndex = disclose(0 as Uint<64>);
  payoutPointer = disclose(0 as Uint<32>);
  totalContributed = disclose(0 as Uint<64>);
  contributionsReceived = disclose(0 as Uint<32>);
  
  member0 = disclose(pad(32, "empty") as Bytes<32>);
  member1 = disclose(pad(32, "empty") as Bytes<32>);
  member2 = disclose(pad(32, "empty") as Bytes<32>);
  member3 = disclose(pad(32, "empty") as Bytes<32>);
}

// ============================================================================
// WITNESSES
// ============================================================================

witness adminSecretKey(): Bytes<32>;

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

circuit publicKey(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "silent-loan:pk:"),
    round as Bytes<32>,
    sk
  ]);
}

// ============================================================================
// MAIN CONTRACT CIRCUITS
// ============================================================================

export circuit joinGroup(): [] {
  assert(circleState == CircleState.JOINING, "Group not accepting members");
  assert(memberCount < maxMembers, "Group is full");
  
  const sk = adminSecretKey();
  const memberPubKey = publicKey(round, sk);
  
  // Add member to next available slot
  if (memberCount == 0) {
    member0 = disclose(memberPubKey);
  } else if (memberCount == 1) {
    member1 = disclose(memberPubKey);
  } else if (memberCount == 2) {
    member2 = disclose(memberPubKey);
  } else if (memberCount == 3) {
    member3 = disclose(memberPubKey);
  }
  
  memberCount = disclose((memberCount + 1) as Uint<32>);
  
  // Start first cycle if group is full
  if (memberCount == maxMembers) {
    circleState = CircleState.ACTIVE;
  }
}

export circuit contributeToPool(amount: Uint<64>): [] {
  assert(circleState == CircleState.ACTIVE, "Circle not active");
  assert(amount == contributionAmount, "Incorrect contribution amount");
  assert(contributionsReceived < memberCount, "All contributions received");
  
  // Update pool
  totalContributed = disclose((totalContributed + amount) as Uint<64>);
  contributionsReceived = disclose((contributionsReceived + 1) as Uint<32>);
}

export circuit executePayout(): Bytes<32> {
  assert(circleState == CircleState.ACTIVE, "Circle not active");
  assert(contributionsReceived == memberCount, "Not all contributions received");
  
  // Get current payout recipient based on payout pointer
  // Note: This approach avoids complex conditionals
  const recipient = member0; // Simplified for demo
  
  // Reset for next cycle
  totalContributed = disclose(0 as Uint<64>);
  contributionsReceived = disclose(0 as Uint<32>);
  currentCycleIndex = disclose((currentCycleIndex + 1) as Uint<64>);
  
  // Advance payout pointer
  if (payoutPointer + 1 >= memberCount) {
    payoutPointer = disclose(0 as Uint<32>);
    circleState = CircleState.COMPLETED;
  } else {
    payoutPointer = disclose((payoutPointer + 1) as Uint<32>);
  }
  
  round.increment(1);
  
  return disclose(recipient);
}

export circuit emergencyDefault(): [] {
  const sk = adminSecretKey();
  const adminPubKey = publicKey(round, sk);
  assert(adminPubKey == admin, "Only admin can trigger emergency default");
  
  circleState = CircleState.COMPLETED;
}

// ============================================================================
// VIEW FUNCTIONS
// ============================================================================

export circuit getGroupParams(): [Uint<64>, Uint<32>, CircleState] {
  return [contributionAmount, maxMembers, circleState];
}

export circuit getCurrentStatus(): [Uint<64>, Uint<32>, Uint<64>, Uint<32>] {
  return [currentCycleIndex, payoutPointer, totalContributed, contributionsReceived];
}